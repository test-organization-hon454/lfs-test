welcome to mythbusting best practices in Unreal Engine I am your host Ari
Aron and just a little bit before we start is that I just published the text
version of this article just now so if you'd rather not sit through my antics
you can just leave and scan this don't leave please no it was a joke or you can search mythbusting best practices in
Unreal Engine online uh it should be inex already or just go to games Sy at the top right there you can share this
with your co-workers so I'll give you one more
second yeah Best Practices you noticed uh I put it in quotes best practices
so-called best practices the thing about them is that many of them are true they they come
from you know some sorts of experience but the thing is many of them are also bust but in all cases you need more
context and that's what I'm trying to give you here today with this presentation I'm trying to give you more context all of these things so actually I want to play a game and you are all
invited to play with me we're going to play true or bust woo I will ask you we
have nine myths I will ask you which one which one says this is true which one will say this is bust and I want you all
to raise your hand with whichever one you think is true robust and I know I know many of you are like it
depends boring so boring I am always going to pick either true with a little
like Aster but remember or I'm going to pick bust but I I'll always say but but
I am not going to I'm not going to go like it PS and I don't want you to do that either so first I'll uh give you a
myth I'll explain a little bit about it and then I'll ask you to pick one and if I count something that doesn't add up to
you know everyone in here I will call out the crowd as cowards don't want that to
happen but I think you you've been good sport so far so let's see first myth
don't use tick oh wa wait wait get there I'll get
there we're going to do this the scientific way so first what is Tick for the ones who are like what's tick tick
is a function that any object can implement or actor to have some code running on every frame of the game and
some people online or even your C say Hey you shouldn't use tick I Hest see
how many people here agree with this how many people here say yes don't do sck
about 10 about 10 out of 300 how many people here say this is
bust you can use tick hey come on okay I would say about
90% of you and there's about 7% here there are
cowards pick one come on it's fun anyways let's talk about tick a lot of
gameplay code happens in tick functions and the tick they only run on the game threat and it's single threat
IT Tech is powerful all right we have the tech groups you can do something before physics you can do them after
physics or if you are not I want to give a special shout out to during physics if
you are not planning on uh reading any transforms or if you're not planning on
modifying any transforms instead of doing your code and then the physics simulation you can do them both at the
same time quite cool you also have tick dependencies you can say I my will only
tick after that one actor has ticked and that actor can have another dependency so that's quite
powerful you can change the tick inter interval of any actor at any time for
example instead of ticking every frame say oh tick only like once every 100 Mill uh one millisecond or uh once every
0.1 millisecond you can change it at any time and you can also disable ticking and enable ticking for an acor at any
time but the thing is it does have a slight overhead because of those features and let's talk about this
overhead um it is slight and it is only noticeable when you have lots of ticking
actors but the overhead itself is usually
negligible compared to the work you're doing during tick and I thought well I'm
wearing a lab coat story behind this one and I thought let's just measure it okay so this is a little like this is on my
computer which is a 2.69 GHz thread dripper this is also an UNR 5.4 so in
the future we might make the ti Sy faster or something might not play anymore and uh yeah so this is Tick
overhead per actor in micros seconds for your information there are 1,000 microc
seconds in one millisecond there are about 16 milliseconds per frame in a 60 frame per second game
so if you start having lots of ticks in your game you'll start it will start showing up in two places on the profiler
it'll be the queuing of the ticks and here we have how much how much time that takes in the blueprint editor um queuing
of it we have the blueprint package development build we have a C++ editor and C++ package development build and
they're all about the same with a little like fluctuation because of profiling isn't an exact uh reproducible
sence but then we have the take overhead of actually calling the ti itself and we have the blueprint editor which is
taking three and a half microc we have and when we package it we it already has
so a packaged blueprint tick and a development build will only take 1.8
micr and then if you decide I don't want blueprint I want to convert it to C++ and you only have a C++ function it will
take about 0.6 to 0.7 uh both an editor and a development
build and I like I know what you're thinking yes I do don't correct me I
know what you're thinking take overhead you see blueprint editor taking you go like oh it's so big a big bar it goes
from the bottom to the top of the slide it's so slow but the thing is is uh I think
usually having some context makes this you know make a little bit more sense so let's add some context so here we have
again the tick overhead from the previous slide just overhead not the Q in and uh this is from Lyra this is from
Lyra's uh player character and there's a few function that happens in lra's tick function we have the character movement
component that takes 241 microsc right then we have also the player controller
itself which is called in Lyra and that is taking 125 micros and just those two together even with
the blueprint editor tick you know what I measured I was like what is the ratio
of a Mars bar to its wrapper and what is the ratio of the
tick to those two functions and the tick is actually lighter than a marsar wrapper and I don't see many people
buying a marsar and go like I'm paying mostly for the wrapper no and you're not you're not paying mostly for the tick
not in this case and a little extra case here you see the I had a little extra
there there the Lyra rifle skeleton mess it's taking 20.7
microc and uh when I saw this on the profiler I was like this the the rifle
gun is a skeletal mes and I looked into it it has two animations one of them is reloading which the magazine pops out
and goes back in and this one is from when you're shooting do you know what the rifle does when you're shooting the
barrel goes like tip the tip of the barrel goes like this a little bit 20 microc 7 and you
don't see anyone shouting like oh the rifles and lra too slow no and you shouldn't be doing the tick either in
this case however of course you know it depends because if the tick is doing less let's say the absolute worst thing
you could be doing is that you could have an empty tick because then you have nothing but overhead and if you have
1,000 actors with an empty take while 3 and a half micros times a thousand is
now 3 and A2 milliseconds now it's a chunk of your frame time so how do you
how can you avoid an empty take overhead first we have here a just don't have a tick function this is in Blueprint so if
you just don't have a tick function no tick overhead don't worry about it if you have the ghost tick function don't
worry ghosts aren't real it doesn't tick but the thing is as
soon as you connect that even tick it materializes into a real tick function and if you later decide never mind I'm
not going to I'm not going to do that and you disconnect it the tick is still there even though nothing is connected
to it it's still materialized and um this actually is an empty tick function
and it will now take three and a half micros seconds of just pure
overhead um people have like there different ways to like find this you can
make an asset validator it shouldn't be that complicated I actually tried making one and uh actually yeah I'll try I'll
add it to the article the the validator so you can check it in your
project funny thing is also like the blint compiler will decide whether it enables tick or not and we could just
add it as a check in the blueprint compiler like hey if the tick isn't connected to anyone maybe just treat it as it doesn't exist this is for our
engineering team let's fix it I have a comic for you all let's say
you're doing some blueprints maybe you're a you know Junior programmer or a game developer doing some blueprint
you're setting some stuff the game is running really well 120 FRS per second you are like oh let's put a
sequence here and there let's do some uncomplete do a little bit more frame is time is going up a little bit let's get
all act of class let's uh put put some more wires in there right collect some more notes but eventually you might
start wondering why is it so slow what's happening and someone who's experienced
might walk by you might you know talk to you online and they they have this they have only time to say this one sentence
they go and look like they go like I've seen this before just don't use tick and just walk away and like a
junior developer will have this advice and like don't use tick like never ever
is it like a forbidden function by the way um I got Victor from
Dev team live to uh draw these comics for me if you like these Comics is you go to his website Dev team live.com he
also has this book The painfully relatable book about game it's amazing as you check it out thank you Victor for joining my presentation but yes the
issue with tick people say tick slows down your game but it's actually doing a
bunch of work per frame per actor that is slow it doesn't really matter whether
you're using tick or timelines or timers or if you decided to have an animation
with an anim notify every frame because I'm not using tick anymore the overhead isn't usually the
issue is all the work that you're doing and if you need something to happen every Fame every frame just use tick if
you need something to happen every frame and you're like I'm not going to use tick because I've been told not to use tick so I'm going to use a timer or a
sequence instead um or timelines I mean then you're kind of missing the point of why
this advice is being given in the first place it's not the take evil function they're just trying to get you to not do so much work every frame um for fortnite
for example we actually have bunch of ticks in the fortnite client which runs by the way on Android and switch we have
about 80 tis on average for a single session so in the beginning there's of of course way more because there's more
players alive and in the end there's way fewer but on average about 80 tick per frame and on the server we have about
700 but try not to do too much work each frame no matter which method you use even if you're not using tick um and
that can be from either having just fewer ticking actors or doing less work per tick that should be the advice and
also just don't take actors that have no business ticking for example let's say you have have a bullet H game and you have 1,000 bullets and these should not
each be their own actor with their own tick function because then again three and a half milliseconds of your frame
time which is a good percentage would just be going to the tick overhead in that case you should aggregate ticking
it's actually a great um presentation about aggregate taking by the Sea of
Thieves developer online it's it was on at anal Fest the first PR one before Co
um so in that case just make one actor called a bullet manager and have the bullet speed for example inst the static
meses then you only have one take but you're doing a lot of stuff and if you do have a lot of data you need to crunch
you can use Mass I'm not recommending this lightly Mass is like a very invol system it needs like a programmer but
you have that option and I actually I was talking to the unreal Source uh Discord channel uh Discord admins say
woo they're here yeah yeah so um unreal source.com
go there uh there's like 111,000 members there anyways I was talking to them about this presentation and uh koos
Spectrum said yeah you know what I think you don't use tick as a bad advice I think the advice should be use tick
don't abuse tick and I was like I'm stealing this but I'm quoting him so it's not a real theft but when do you
know when you're abusing tick well you profile profile your profile just
profile take the profile everyone has access to it so yeah when it comes to don't use tick I would say this is a
bust you can use tick however don't do too much work in tick and of course don't have an unreasonable amount of
tick running and when do you know when you have an unreasonable amount of TI you profile you profile okay next myth
you cannot make 2D games in unreal who says this is true you cannot make 2D
games in unreal I see one two same amount of Dimensions as there
are people that say you cannot make games in [Music] unreal but for Prosperity how many say
this is bust you can definitely make Tut games in unreal okay no one's going to be called
the cover this time actually you know what I don't know I've never made a to game in
unreal but but it's okay as a scientist I asked someone who does I found someone
online who actually is a torch Bearer for 2D making games and tutorials his name is Cobra coat Cobra coat can you
please answer this myth for me hello everybody I'm and thanks for having me as a guest Ari I'm Cobra code and I've
dedicated the last three years of my life to teaching people how to make 2D and 2D 3D hybrid games with Unreal Engine like most other developers I also
thought making 2D games with unreal was impossible or at least unfeasible since a few years ago there really wasn't much
information about it available but after I decided to just give it a try I quickly realized the untapped potential
of paper 2D paper 2D is an official plugin that has been around since unre engine 4.3 allowing us to create Sprites
flipbook animations tile sets and tile Maps inside of the editor and it's actually active by default in all Unreal
Engine projects these Sprite assets can then be used to create 2D games that consist of sprite's only or 2D 3D
hybrids which mix 2D Sprites with 3D elements however sadly paper 2D hasn't been in active development for quite a
while and some features are stuck in a Perpetual beta State doing things such as triggering events on certain
animation frames multidirectional animations and switching between animations in general all have to be
done manually within blueprints or C++ which works just fine but can often be cumbersome and timec consuming this is
where the free paper ZD plugin steps in which is an epic Mega Grand recipient and extends paper 2D's functionality it
allows us to create 2D animation blueprints which look very similar to the ones we get with skeletal meshes
enabling us to use State machines for switching animations setup animation notifies to trigger events on flip Hooks
and it even has built-in support for multi-direction animations with up to 16 directions making it easy to create top
down games using these tools the possibilities are almost endless and I've made prototypes for jump and runs
beat them UPS top down adventure games action Platformers and much more you may
be concerned about performance or the package size but there are many ways to reduce package size with unreal and I've
gotten 2D games down to an Onis disk size of roughly 150 mbes and a download size of roughly 90 mbes regarding
performance performance I was able to make a blueprint only 2D game run at 370 FPS on the steam deck by only changing a
few project settings there also many more unreal 2D and 2d3 hybrid games than you might think The octopath Traveler
Series or Ander lies are the most well-known examples but there are also many other awesome projects such as the
siege and the sand Fox the vagrant demon Crush
snackco forgive me Father and born of bread true or bust in
this case it's a bust you can make 2D games in unil just fine as long as you know how to work around some limitations
and spend a bit of time on optimization thank you Cooper coat and
actually since Cooper coat made this video for me he's actually released the
ultimate 2D top- down Unreal Engine cords and I got his permission to give you this link which has a huge discount
on the course or just go to tinyurl.com unreal to the top down
few more seconds so you can take a picture of it or something okay thank you for busting this myth next myth is blueprints are
slower than C++ what even are blueprints well blueprints are UNR scripting language it
looks like this has got notes so you don't have to be coding you can just do some visual uh magic things okay anyways
people say blueprints are slower than C++ who says this is true they are
slower okay okay so about everyone who who says this is a bust BLS
aren't slower than C++ I'm a designer oh want designer there 1 2 3 4 5 6 s about
seven out of 300 thank you let's talk about blueprints so blueprints do run in
a virtual machine and there is a set overhead for each blueprint call but after that it is all in C++ that means
if you have very few calls you have negligible overhead and I made a little function here just an example and it so
it prints a string it doesn't work for the amount of time that tell it to do some work and then it print the string
saying it's done and calling into a C+ plus function like that that's has been marked with a u function and you can call into it uh it has uh about 0.8
micros seconds of overhead in the editor before it gets into it on my computer on
5.4 um and then in a pack is development game it takes 0.7 microseconds but that's not the only overhead there's
also an overhead between the nodes so in the editor in blueprints it will take about half a microsc and then in a
package development build it will take 0.1 microsc quite fast and
um yeah how much slower is it well let's check out a few different amounts of
work let's say do work is doing one millisecond of work this is a screenshot from un
Insight is a time it goes from left to right and then when it goes into a function it goes down first we have print string then we have do work one
millisecond then we have another print string which in this case is taking 272 microc and blueprint overhead will show
on the profiler as a space between the functions and uh when you go into C++
land it will show as offset and there's not really anything there so this this
function in this case is about
0.00001% slower in that case but okay do work one
millisecond 1 millisecond is a very heavy function that's like four character movement components so let's
divide it work by 10 let's make it take about as long as the print string is taking so here we have print string
taking 90 microseconds in this case I don't know why it jumps between 90 and almost 300 but maybe it's flossing or
something like that anyways print string 90 then do work 100 and then print string 95 now you can actually see if
you squint one pixel between the first print string and do work and if you
squint really hard you might see one pixel maybe two offset between do work and do work
C++ but okay let's say well 100 microc is still quite slow for C++ function
let's go to something a bit more you know realistic so anything anything between 10 and 100 microc let's go to 10
now we can start seeing the overhead now we can see the space between the functions and now we can see the offset the offset between do work and do work
super plus you can see 10.8 versus 10 so that's the8 microc overhead that I told
you about in the previous slide but let's say I want to see it with even faster function super plus function that does
just almost nothing it's one one micros of work in this case the overhead is
actually between the nodes and the offset is a bit more than what the C+ plus function is doing and this is when
you're calling into C plus there are also other um notes for example this math notes Set uh for E that are only in
Blueprint land and those are basically 100% overhead because it never goes into C++ land
so why am i showing you all of these different numbers the thing is like how much slower are blueprints um are
blueprints usually a question and it's not really a multiplier like it's not like a blueprints are 10 times slower
than super plus although like we have set that but we always given the uh context of like but you know it depends
so sure for some graphs like if you have lots and lots of notes doing a healthy mixture of like math and stuff it might
turn out that one specific blueprints were 10 times lower but usually you should think of it as an overhead per
note that's the overhead and when it comes to just best practices
with blueprints I actually decided Michael allar decided to get his input on it because he's been giving advice to
H developers online for like so many years and I was like all you so smart can you can you help me collaborate on
this and he's like I got you fam and he sent me this video which I just put in right now let's check it out let's take it out together should I use blueprints
or shut up use whatever is comfortable but I heard blueprints are slower than use the profiler
oh that's it I thought it would be longer the other one was like three minutes okay
thank you Michael I actually agree with it this is quite uh quite nice but I'll add a few more best practices of my own
if the blueprint overheads for some code is causing you issues you should move that code to C++ because believe it or
not there is no trophy for shipping a game blueprint only I know some of you might be purist like I don't want to
touch C+ plus but the thing is like if you go to the game awards you don't see Jeff key on stage saying and for the
game that made a g it only blueprints there's nothing like that there is an award for the best game you
should try to get that the best game and um that means moving a couple of your
functions to C++ only even though you don't get to call yourself a pist anymore if it helps you with the game
you should do it but that only gets you so far um let's say you take a function
you see on the profile around it's so slow let's move it over to C++ but often times you're just still doing too much
it's still slow like sure moving it over gave you like a 20% speed up but you can't for the same function like just do
it again I mean you I guess you could move it over to assembly don't do that
don't do assembly sorry forget I said that um because often times you're just doing too much then you might decide oh
I know like all the enemies they're ticking and they're taking too much frame time I'll uh I'll only have the enemies that are close to the player
tick every frame and the enemies that are a little bit further away I'll tick them every other frame and the enemies that are behind the player I'll tick
them once a second and think about like those are good optimizations but the thing is those optimizations would have
been valid whether you're using blueprints or C++ so yeah like moving things from Blue
to super plus isn't a hail Mar it's not going to make everything like super fast and just run wonderfully every time um
sometimes just doing less per frame by being smart is the way to go and how do
you know whether You're simply doing too much you profile you're getting it okay so
when it comes to blueprints are slower than C++ it wasn't a trick question it is true uh but that doesn't mean you
shouldn't use them not at all they're also super versatile and very fast to iterate on and they enable non-coders on
the team to contribute code which is very nice you know what I did some tests I
ran some numbers I actually figured out the best mixture the best ratio of
blueprints versus C++ to have in a project there's a single answer to it and the answer is whatever ships your
game that's it if you are a bunch of designers and you don't know how to code and you want to make a blueprint only
game and ship it and make lots of money to make your next game that was the correct version correct ratio of
blueprints versus plus if you're a bunch of Hardcore coders and you hate blueprints with the passion of a th000
then do it all in code and Chip your game and make enough money that you can make your next game so yeah that's the
perfect ratio I actually asked one engineer how how much blueprints are
there in fortnite and they quoted I don't know if they allowed me to quote them so this is be anonymous quote uh
they quoted they said a lot lot all in caps so in fortnite we have a lot of
blueprints next myth don't use cast o spicy what is cast cast is a note that
converts a pointer of some data type to another type with type checking for
example uh just to give you an example what it means like here we have uh let's say it's a trap and we have an begin
actor overlap whenever something overlaps with a trap I'm going to say is this actor which I don't know anything
about is it the player character because if it is the player character then I can get the reference to the player character now I can call functions on
the player character you basically cast to it but some people say you shouldn't
use it don't use the cast function who agrees with it who says you should not use cast let me see the
hands four five five five six five six hands out of 300 okay who says this is
bust oh you can definitely use cast okay about 80% of you the rest of
you are cowed let's talk about castom um some
say cast is glow cast loads assets as a Reon to not use cast but the thing is
the cast function is an integral part of coding in both Blueprints and C++ and it's not the slow it's actually it's
about half a microsc to C+ plus and it's about three and a half microseconds in Blueprint editor which is about the same
as the tick overhead because it's just it's just a blueprint overhead basically uh but this is on my computer so your
myets may vary but the issue with cast is that casting to ruin type will also
reference it which as it as dependency and dependen is they need to be loaded before your blueprint is loaded and they
Stay Loaded while something references them give you an example of where this was bad from an actual actual real world
example you have a player character and they have a function called I've been grabbed and um we had this last boss of
the game that would do something special when it grabs you so we would of course cast to the last boss and say if it's
the last boss do something weird and I'll tell you like you can have all the systems in the world for all the enemies
that this always works but when it comes to your bosses you're going to need to do some weird stuff all around your game and like that's just the way like it's
just like bosses are they are really cool and they do a lot of cool stuff and you're just going to have to deal with
it but the thing is now because of that reference before the player can be fully loaded it first also needs to load the
end game Boss and while the player is loaded which is always the player BS was
in memory so that means that uh yeah the game loaded a little slower because it needed to load
the end boss before the player could be loaded and also meant that we have memory pressure like the end boss always
and it meses and everything in memory um all the time but the thing is it doesn't
slow down the actual Cast Operation itself that's always just as fast once you've loaded in so okay when should we
then cast the blueprints I made a flow graph who doesn't love a flow graph and
let's say we have an actor reference and you want to do something with it what do you want to do with it do you want to
call a functionary or do you want to get a property from it if yes I have another question for you is the function or
property declared already in C++ because if it is let's say in one of the parent classes because if it is you can just
cast to the C++ parent class because the C++ classes they don't count as you know asses they're always in memory and
they're quite tiny so you can cast to them without any penalty of reference loading so just do that feel free that's
fine I you have my permission but what the function or property is not declared in C++ I have a new question for you is
the Blom class expected to be always loaded anyways let's say you know is it player character is it the game instance
is it the game mode one of these classes that you know is going to be in memory at that time in that case just cast to
that blueprint because even though you're adding a dependency if it's already loaded un isn't going to load it again it's smart enough it will go like
uh I need to load this oh it's already loaded never mind so just cast to The Blueprint cast to the player character plus to the cast to the game instance go
ahead but what if the blueprint class is not expected to be always loaded I would say then get a programmer or yourself if
you're a programmer to define the property or function in C++ and then you can override it in Blueprint that way
you can cast again to character but what if you don't want to call a function on it what if you no
sorry what if you don't want to define the property of function in simple plus you're going for that purest game award
trophy which doesn't exist um or maybe you're like H but all there's all these different actors and they have different
parent classes or like I can't or I won't in that case use an interface that's what they're for many people will
default first to go in for interfaces I would say well I would say First cast to the C++ CU that's just like you know in
my opinion way better but if that can't or you won't do it then use an interface
go ahead it's totally fine but now if you don't want to get a function or a property from the actor what if you just
need to check the type I say don't use the cast function you should use this function compare with soft class you you
use S A of the type soft so the object goes in and you say is this a soft class
player character and when you do that you're not adding a reference because it's soft and not a heart reference and
some of you might be thinking I've never seen that function before well okay ah you got me it doesn't
exist we added it in 5.5 it's going to exist very soon but until 5.5 it's it's
fine you can you can make this functionality yourself it's actually quite simple just uh get the player class and resolve it add the cast it to
a class if the class is loaded and then get the actual class and just compare them and if it's not and if it isn't
loaded uh the player class will Sol to no which in that case it's not the same thing because it's not loaded okay and
also you you can of course you know use actor tags or gain pay taags just check like oh does it have a jumper on it then probably has the jump function uh
something like that and yeah but if you don't need to check the type and you still want to use cast um I don't I
don't know you're doing but you probably don't need a cast but yeah when it comes
to don't use cast I would say this is a bust you can use cast all was want also if you're doing this in C++ it doesn't
really apply there if you're a C++ programmer you're already using cast left and right and you never heard this rumor probably um but yeah be careful
with heart references that's that's the only thing next myth if it can be nanite
it's shiing Nite o actually I have no idea I'm not a tech artist and the guy
who said it Matt UST oh he like he he got people questioning this one so I just went to him I said like Matt you
need to answer this one you you started this and uh yeah Matt OS is not
unfortunately Matt we miss you but he is here virtually so he is going to take over this myth for me Matt take it away
thanks aie that's right some of you may have heard that uh if it can be nanite and you're using nanite it should be
nanite but that seems pretty flimsy the myth I want to bust is everything should be nanite because it will fix everything
and run faster always and I think it's helpful to have a basic understanding of what nanite is doing before we start
raising hands but quickly nanite is a virtualized microp polygon rendering system that aims to performant provide
nearly Pixel Perfect lods at a higher level of fidelity than was previously possible than with the traditional
lotting and rendering techniques it does this by first grouping your input meshes into clusters of about 128 triangles
then simplifies that geometry into lower and lower levels of detail these clusters are streamed in as NE to
achieve a resolution of no greater than 1 pixel per Edge prior to rasterizing nanite Coles Primitives instances and
even individual clusters in order to ensure it only rasterizes what's visible then it chooses a rasterization method
based on the size of the triangles in a cluster bigger triangles use the traditional Hardware rasterization path
whereas more dense clusters use nanite software rasterization path to efficiently rasterize those small
triangles rasterization sends the pixels occupied by each material to the base pass for shading so three different
rocks using the the same material all go into a single shading bin and nite's new compute shading means it only needs as
many shading bins as there are materials visible on the screen at any given time pretty great right so what do we think
do we think this myth is true you kind of change the question but I'll allow it so everything should be n because it
will fix everything and run fast always who says yes one two 3 four five six
seven I like how the hands just keep popping out seven okay Matt it's seven
or do we think it's bust how many think this is a bust the rest of
us Matt Matt almost everyone thinks this is a bust do you think that's fantastic
fantastic let's break this up into two parts first what if I told you not everything can be nanite translucency
and Niagara aren't supported and skeletal meshes are experimental just now in 5.5 additionally nanite isn't
available on all platforms so if you're targeting those platforms you'll still need to plan for non- nanite paths but
surely the things that can be nanite will improve performance right actually
it's quite possible to cause new and different performance issues than you're used to from non- nanite rendering
stacking geometry closely together means that nanite can't effectively call the clusters of the further mesh which could
result in bottleneck due to nanite overdraw expensive masked and wpo materials can result in significant
progam scramble rasterization costs for nanite and vssm by extension you can also cause rasterization issues if your
wpo material scales a cluster in such a way that its transformed size mismatches its untransformed size and thus the
cluster's raster mode is mismatched and you can create an excessive number of shading bins using things like Dynamic
material instances so what does this mean for our myth well not everything can be nanite
and nanite can cause its own performance problems which means I think this is a bust but I don't think that means you
shouldn't use nanite leaving aside the performance benefits of nanite to the other rendering systems like Lumin and
virtual Shadow Maps Nite does allow for models with a higher level of detail than previously feasible through its new
approach to simplification and rasterization and it can prove more efficient when rendering scenes through
its Bend shading approach just remember to profile evaluate and optimize as you
go back to you aie thank you Matt look at that TIY bugger okay I actually think
he rewarded the um myth just so that he could say that he came on my
presentation to bust himself dirty boy okay next myth thank you Matt get all actors of class is
slow what is get all actors of class it's a function that allows you to get a list of all actors of a certain type
currently alive in the world and depending on who you ask some people will tell you you shouldn't use it
because it is slow how many people say this is true about a quarter to a third of us
think this is true how many of us think this is bust you can use that
function a third of
us cowards let's this is this is divisive
one but don't worry I'll get into it let's talk about get all actors of class the thing is it scales directly with the
amount of actors it actually gets so if you're only getting few actors a few
dozen it's very fast and honestly it's used by the engine we even call it a few
times every frame and shipping builds there's three calls to it by two of our subsystems and some of you might be surprised and I think maybe some of our
rendering Engineers or like engine Engineers might be like oh really and I might look into it anyways yeah it's
happening and it's not noticeable because it's very fast right it actually uses hash buckets so it's very efficient
it used to it used to Loop over every single actor in the map and check if the actor was of the type so that so it used
to be slow it used to be true but you know what I decided to check just how long
ago was that it has not done that in over a
decade this myth has persisted I checked it's 11 years ago
that we changed that but I will say one thing we did forgot we did forget to change the comment for
the note the note says this is very fast no very slow I mean don't use it every
frame sorry about that that might have cost a little bit of
misunderstanding my bad but during this presentation we noticed it and we decided to fix it so in 5.5 this comment
has been fixed wo so no more misunderstandings uh
yeah thank you Ben Zigler for changing those comments for me of course that just means don't get an unreasonable amount of actors and don't do too much
work for each actor if you're looping through it again just like you know don't do too much of anything however it's siblings we have get all actors
with interface we have get all actors with tag they still don't have any hash buckets they Loop over every actor which
is slow if your world gets big and the bigger your world gets the slower they get so that means get all actors of
class it's always fast no matter how big your world is as long as you're only getting a few few actors like few dozen
uh maybe up to it but after that like it does still do a check on every re actor is it alive is it pending like
incremental garbage collection so if you go up in a thousands you're going to see it but how do you know uh how many
actors are too many you profile you're getting better at that so okay get all
actors or class is slow is that true or bust I would say this is a bust but for a reasonable amount of actors and of
course if you're looping through them make sure that you are mindful of how much work you do for each actor
next myth don't use child actor
component what is the child actor component so it's a component that allows you to have your actor
automatically spawn and attach a child actor during construction and for some
reason a lot of people say that you just should not use it how many people agree with that how many people say you should
not use the child active component only like 10 15% of us okay
how many people say this is bust you can use a t component go ahead about 20 to 25% of us okay we're
getting more into the Wheats now which I like but I don't like how many cowards there are in this room let's talk about
the child component users coming from other engines will often use it to replicate prea
[Laughter]
functionality when they do that they encounter issues instability and crashes because tell it does really
stress test our reinstancing system we do use it we use it in on fornite but for very simple attachments like only
for visuals for V effects and we don't do any nesting anything more complicated like if it's related to
replication or nesting you want the chor within the child doctor or it'll probably give you
issues if you want to get close to preat workflow you can just attach like within the ACT blueprint the components to each
other so you can have like components there uh not child actor components just child components uh or you can even in
the world you can attach pre-existing actors in the world outliner that's not really a preat workflow though or you
can use level instances which now in 5.5 or 5.4 I can't remember which one will allow you to do per instance override so
it's like kind of diet prefab but the thing is uh we do have scene graph which
will have a way better prefab workflow it's the prefab workflow that you know from other engines not going to name them but the ones you can expect how it
will work right and we actually have it right now experimental in ufn um I don't
think you can publish your Islands yet with it but this is a great time for you to finally check out ufn just see how
this works for you and if it fulfills all of your conditions because if it doesn't you should tell us now because
now we're like molding it so if you just forever hold your silence we will assume
you love it but yeah don't use child component
it's true don't use it I would say that because of all the issues maybe if you
have very simple use cases you only want to attach you know a visual or like a VFX or something no nesting no
replication nothing like that sure do it that's how we use it that's kind of we meant to use it but we didn't know user
would just go like apes it with it so uh don't do anything more with it than that
so yeah just like as a good rule of thumb just don't use it okay uh next myth unreal Cooks everything by default
Cooks everything what you cooking so cooking when package in your game unal
needs to cook the game assets to run on the target platform this is like compressing textures compiling
blueprints compiling shaders and um you would think that maybe it only Cooks
only what you use or you would think that maybe it Cooks everything by default who here says yeah this is true
it Cooks everything by default in your project 1 2 3 4 5 6 7 eight I see half
hands put your hand all the way up don't be shy wow nine okay 10 okay who says
this is bust it only uh does like what you actually use and stuff like that okay about half of your rest of cards
blah blah blah okay let's talk about cooking cooking is timeconsuming it's very timeconsuming if you've seen some
of the other talks trying to make it faster but in anyway you you want to you only want to cook the assets your
project actually uses but the thing is unreal cannot know which assets you're
using or not like for example what if there's an actor that isn't referenced by anything but you want to spawn it via
code just with its path so if you don't tell unreal which assets you wanted to cook unreal will just default to just
cook everything so that's the default so like you can break that functionality by
just telling un to cook anything and then we'll just cook that nothing else so how do we tell unal what we want to cook there's a few ways to do of doing
it but I recommend that you use the primary asset rules and um you can configure them in the project
setting just change the map rule to always cook and disable the editor only book to only cook all the levels in the
maps folder and only that folder uh and then what they reference and what they reference and what they reference so on
and of course like your uh game instance game mode uh those will also get cooked of course because they're being referenced from the pr settings and I
think this I think this should be the default personally but of course I understand oh like what if users want to
do something weird like spawning something dynamically from code then okay let's just cook everything but if you do that it's going to be closer to
like what I expect on to do by default and if you need other classes for example you have like dynamic spawn
enemies or Collectibles that you only spawn via code and you want to be able to reference them I would say make them
primary assets you do that by just overwriting the get primary asset ID function and then listing them in the
primary asset types to scan in the prod settings that's all you need to make something primary asset and you can give it a cook rule um or you can override
the asset manager which I recommend every bigger Studio do it allows you to just basically go Haywire on making like
everything super customizable but for smaller projects uh don't bother if you don't need it there are other methods of
course you can you can put something into directories to always cook or you can use the maps to cook uh yeah that
works you can use both either or I recommend just going full on with the primary asset rules or customizing the asset manager so when it comes to this
unal Cooks everything by defa by default it's actually true but it's easy to change which you should do okay we have
one more myth and that is you should avoid redirectors or clean them up as
soon as possible what are redirectors glad you asked they are small metaphil
that UNR relieves when you move aets and this metaph then points to the new location of the asset and this is needed
because unal doesn't use Global unique identifiers skids it uses file pass so if it's pointing to something and it
moves the asset it's still pointing there so the redirector will tell it oh look over there
instead okay but people say the r directors uh don't keep them in Pro you
you need to avoid making them or if you do make them you should clean them up as soon as possible how many people say this is
true oh wow like 2/3 almost four I would say just almost everyone like 80% of us
how many people say this is bust 12 out of 300 let's see let's talk
about redirectors the thing is if you're not connected to Version Control even unreal won't even create them in the
first place if you can avoid it it will just fix them up immediately so if you move an asset and will go like wait wait
wait and it will go to Every asset that points to that asset and say the asset is over there now and then resave them
which is a little bit slow but at least you don't have to worry about redirectors
but they are important in team workflows however and I'll give you one example of
why you shouldn't fix up redirectors as soon as you can let's say Anna creates a
new asset which she has not committed yet it's just on her computer and that points to blueprint
important like this I practiced this and now I [ __ ] it up okay anyways if Bill
moves BR important un will leave a redirector in case any asset anywhere points to it the thing is Anna hasn't
committed her asset yet so Bill might remove that redirector thinking ah he fixed up all assets that were
referencing it because nothing was committed that do still now Anna commits her asset and it
breaks the project because it's referencing an asset which doesn't exist in the location anymore so yeah this is
the reason and um you might think oh this is very rare though you're right it's very rare in smaller projects and
as soon as your team start scaling up this rare becomes a bit less rare and it
becomes a problem that you have to fix every once in a while especially at a scale like fortnite this is such a big
issue that we actually have a rule of when to fix up redirectors for us it's best to do it when you can be sure no
asset whether it's committed or not is pointing to them and how can we be how can we know that well there's actually
one time of year when everyone goes on holiday where we just start a task that Reaves all assets and fixes up the
redirectors and then we like just like okay turn off the lights and leave uh just after everyone leaves on
holiday and you can do that via the resave packages commandlet uh we don't really have good documentation about it
sorry but if you just search for resave packages commandlet there's a C file
that basically calls the C+ plus command there's so there's two classes called resave packages something check them out
it will show you the parameters and stuff like that uh maybe if some of you figure it out maybe you can make an
article on uh EDC tell me about it and I'll link it from the text version of this article anyways uh when it comes to
avoiding redirectors clean them up ASAP maybe you know for very very small teams
you're not worried about it but I would say this is a bust you should only clean them up when you know no one else on your team might be referencing them um
this was the last myth we only have 30 seconds left so I'm not going to take one question right now but uh I will be
at the dev Hub right after this for a whole hour you just follow me and we'll go there right after this but um I will
just hope you have a great rest of under and I want to say thank you very much